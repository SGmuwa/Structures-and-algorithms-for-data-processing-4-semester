Постановка проблемы.

Разработать функцию вычисления определенного
интеграла с заданной точностью. Использовать разработанную функцию при
вычислении интеграла от заданной подынтегральной функции. Вычисление
подынтегральной функции оформить в виде функции. Результаты
вычисления интеграла для заданных значений параметра представить в виде
таблицы. Для вариантов 1, 2, 3, 5, 7, 12, 13, 14 включить в таблицу с
результатами дополнительный столбец с количеством элементарных
отрезков, которое использовалось для получения значений интеграла с
заданной точностью. Варианты заданий приведены в табл. 8.

Мой вариант 16. Данные из таблицы:

Метод интегрирования: Метод правых прямоугольников
Подынтегральная функция: xe^-x
Пределы интегрирования (a и b): a=0, b - параметр
Примечание: b=0.5, 1.0, 1.5, 2.0

Формулы численного интегрирования
Метод левых прямоугольников
integral(b, a, f(x)) = h * sum(i1 = 1 ... n, f(x[i1]));

где n - количество элементарных отрезков, на которые разделяется
отрезок интегрирования [a,b],
h = (b - a) / n
x[i2] = x[i2 - 1] + h
i2 = 2, 3, ...;

Конфликт:
найдены две буквы i. Решение: разделить i на i1 и i2



Пример программы
Программа вычисления корня нелинейного уравнения f(x)=0 на
интервале (a, b), на котором функция f(x) меняет знак. В программе
используется функция metod, которая вычисляет корень уравнения с
точностью eps методом деления отрезка пополам. Заголовок функции:
float metod (float a, float b, float eps, float(* f)(float x))

Программа использует функцию metod для вычисления корня уравнения:

x^3-2x-5=0


Корень находится между 2 и 3.

#include <iostream.h>
#include <conio.h>
//Функция вычисления корня уравнения
float metod (float a, float b, float eps, float(* f)(float x));
float f(float x); //функция задает нелинейное уравнение

void main( )
{
	float a=2, b=3; //левая и правая границы интервала нахождения корня
	float eps; //точность вычисления корня
	cout<<”eps? “;
	cin>>eps;
	cout<<metod(a,b,eps,f);
	getch();
}
float metod (float a, float b, float eps, float(* f)(float x))
{
	float x; //приближение корня
	float u,v;//значение функции f(x) на левой и правой границах интервала
	u=f(a);
	do
	{
		x=(a+b)/2;
		v=f(x);
		if (u*v<0) //функция имеет разные знаки на интервале [a,x]
			b=x; //выбирается левый интервал [a, x] для поиска корня
		else //выбирается правый интервал [x, b] для поиска корня
		{
			a=x; u=v;
		}
	}while (b-a>eps);
	return x;
}
float f(float x)
{
	return x*x*x-2*x-5;
}